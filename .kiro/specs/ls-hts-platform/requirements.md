# 요구사항 문서

## 소개

LS증권_개인화_HTS는 국내 주식시장을 위한 자동매매 및 백테스팅 플랫폼입니다. 이 시스템은 Adapter 패턴을 통해 여러 증권사 API(LS증권, 키움증권, 한국투자증권 등)를 교체 가능하게 지원하며, 전략 개발부터 백테스팅, 자동 파라미터 탐색, 실시간 자동매매까지 전체 트레이딩 워크플로우를 제공합니다. 웹/모바일 인터페이스를 통해 어디서나 계좌와 전략을 모니터링할 수 있습니다.

## 용어 정의

- **HTS (Home Trading System)**: 개인 투자자를 위한 주식 거래 시스템
- **브로커(Broker)**: 증권사 API를 추상화한 인터페이스 계층
- **BrokerBase**: 모든 증권사 Adapter가 구현해야 하는 추상 클래스
- **LSAdapter**: LS증권 API를 BrokerBase 인터페이스로 구현한 Adapter
- **KiwoomAdapter**: 키움증권 API를 BrokerBase 인터페이스로 구현한 Adapter
- **전략(Strategy)**: 매매 로직을 정의한 클래스 (BaseStrategy를 상속)
- **백테스트 엔진(Backtest Engine)**: OHLC 데이터 기반으로 전략을 시뮬레이션하는 엔진
- **실행 엔진(Execution Engine)**: 실시간 시장 데이터를 받아 전략을 실행하는 엔진
- **OHLC**: Open, High, Low, Close - 시가, 고가, 저가, 종가 데이터
- **MDD (Maximum Drawdown)**: 최대 낙폭 - 투자 손실의 최대치
- **ATR (Average True Range)**: 평균 진폭 - 변동성 지표
- **피라미딩(Pyramiding)**: 포지션에 추가 진입하는 기법
- **AutoML**: 자동 파라미터 탐색 및 최적화 시스템
- **DIP (Dependency Inversion Principle)**: 의존성 역전 원칙
- **ISP (Interface Segregation Principle)**: 인터페이스 분리 원칙
- **WebSocket**: 실시간 양방향 통신 프로토콜
- **FastAPI**: Python 기반 고성능 웹 프레임워크
- **포지션(Position)**: 보유 중인 주식 포지션
- **주문(Order)**: 주문 (매수/매도)

## 요구사항

### 요구사항 1

**사용자 스토리:** 시스템 아키텍트로서, 나는 브로커에 독립적인 어댑터 계층을 원한다. 그래야 핵심 전략 코드를 변경하지 않고도 여러 증권사(LS, 키움, 한국투자 등) 간에 전환할 수 있기 때문이다.

#### 인수 기준

1. BrokerBase는 get_ohlc, get_current_price, place_order, cancel_order, amend_order, get_account, get_positions, get_open_orders, stream_realtime에 대한 추상 메서드를 정의해야 한다
2. 새로운 브로커 어댑터가 구현될 때, 해당 어댑터는 BrokerBase를 상속하고 모든 필수 메서드를 구현해야 한다
3. 시스템이 한 브로커에서 다른 브로커로 전환될 때, 전략은 수정 없이 계속 작동해야 한다
4. 브로커 특화 기능이 존재하는 경우, 어댑터는 브로커 특화 로직을 코어 계층에 노출하지 않고 내부적으로 처리해야 한다
5. 시스템은 LSAdapter, KiwoomAdapter, KoreaInvestmentAdapter를 독립적인 플러그인 모듈로 지원해야 한다

### 요구사항 2

**사용자 스토리:** 트레이더로서, 나는 과거 OHLC 데이터를 사용하여 전략을 백테스트하고 싶다. 그래야 실제 자본을 위험에 빠뜨리기 전에 전략 성과를 평가할 수 있기 때문이다.

#### 인수 기준

1. 사용자가 OHLC 데이터와 전략을 제공할 때, 백테스트 엔진은 시간 순서대로 거래를 시뮬레이션해야 한다
2. 백테스트가 완료될 때, 시스템은 MDD, 승률, 손익비, 샤프 비율, 총 수익률을 계산하고 반환해야 한다
3. 전략이 피라미딩을 사용할 때, 백테스트 엔진은 동일한 포지션에 대한 여러 진입을 지원해야 한다
4. 전략이 ATR 트레일링 스탑을 사용할 때, 백테스트 엔진은 ATR 값에 따라 손절 수준을 동적으로 조정해야 한다
5. 백테스트 결과가 생성될 때, 시스템은 타임스탬프 및 전략 파라미터와 함께 결과를 데이터베이스에 저장해야 한다

### 요구사항 3

**사용자 스토리:** 전략 개발자로서, 나는 브로커 API와 독립적인 전략을 작성하고 싶다. 그래야 전략 코드가 깨끗하고 이식 가능하게 유지되기 때문이다.

#### 인수 기준

1. BaseStrategy는 브로커 API를 직접 호출하지 않고 메서드 파라미터를 통해 시장 데이터와 계좌 정보를 받아야 한다
2. 전략이 주문을 제출해야 할 때, 전략은 주문을 직접 실행하지 않고 엔진에 주문 지시를 반환해야 한다
3. 전략은 브로커 특화 모듈을 임포트하거나 참조하지 않아야 한다
4. 엔진이 전략 메서드를 호출할 때, 엔진은 모든 필요한 컨텍스트(현재 가격, 포지션, 계좌 잔액, OHLC 바)를 제공해야 한다
5. 전략은 엔진이 제공한 데이터만을 사용하여 진입 및 청산 로직을 정의해야 한다

### 요구사항 4

**사용자 스토리:** 트레이더로서, 나는 최적의 전략 파라미터를 자동으로 탐색하고 싶다. 그래야 수동 시행착오 없이 최고 성능의 설정을 찾을 수 있기 때문이다.

#### 인수 기준

1. 사용자가 파라미터 탐색을 시작할 때, AutoML 시스템은 그리드 탐색, 랜덤 탐색, 유전 알고리즘 방법을 지원해야 한다
2. 파라미터 탐색이 실행될 때, 시스템은 서로 다른 파라미터 조합으로 여러 백테스트를 병렬로 실행해야 한다
3. 파라미터 탐색이 완료될 때, 시스템은 사용자 정의 메트릭(예: 샤프 비율, MDD, 손익비)으로 전략을 순위화해야 한다
4. 상위 N개 전략이 식별될 때, 시스템은 해당 파라미터를 JSON 파일로 저장해야 한다
5. AutoML 시스템은 훈련-테스트 분할 또는 워크포워드 검증을 지원하여 과적합을 방지해야 한다

### 요구사항 5

**사용자 스토리:** 트레이더로서, 나는 실시간 시장 데이터로 전략을 실행하고 싶다. 그래야 테스트된 전략을 기반으로 거래를 자동화할 수 있기 때문이다.

#### 인수 기준

1. 실행 엔진이 시작될 때, 시스템은 실시간 가격 업데이트를 받기 위해 WebSocket 연결을 설정해야 한다
2. 가격 업데이트가 수신될 때, 엔진은 현재 시장 상태로 전략의 의사결정 로직을 호출해야 한다
3. 전략이 주문 신호를 생성할 때, 엔진은 제출 전에 리스크 한도에 대해 주문을 검증해야 한다
4. 주문이 체결되거나 부분 체결될 때, 엔진은 포지션 및 계좌 상태를 즉시 업데이트해야 한다
5. MDD가 사전 정의된 임계값을 초과할 때, 엔진은 모든 전략을 중단하고 모든 포지션을 청산해야 한다

### 요구사항 6

**사용자 스토리:** 트레이더로서, 나는 웹 또는 모바일 인터페이스를 통해 계좌, 포지션, 전략을 모니터링하고 싶다. 그래야 어디서나 성과를 추적할 수 있기 때문이다.

#### 인수 기준

1. 사용자가 HTS 대시보드에 접속할 때, 시스템은 현재 계좌 잔액, 포지션, 미체결 주문을 표시해야 한다
2. 사용자가 전략 상태를 조회할 때, 시스템은 활성 전략, 현재 상태, 성과 지표를 보여줘야 한다
3. 사용자가 백테스트 결과를 요청할 때, API는 차트 및 통계와 함께 과거 백테스트 데이터를 반환해야 한다
4. 사용자가 UI를 통해 수동 주문을 제출할 때, 시스템은 브로커 어댑터를 통해 주문을 검증하고 실행해야 한다
5. API는 대시보드로 실시간 가격 스트리밍을 위한 WebSocket 엔드포인트를 제공해야 한다

### 요구사항 7

**사용자 스토리:** 시스템 관리자로서, 나는 모든 컴포넌트가 느슨한 결합 원칙을 따르기를 원한다. 그래야 시스템이 유지보수 가능하고 확장 가능하게 유지되기 때문이다.

#### 인수 기준

1. 코어 계층은 유틸리티 계층에만 의존해야 한다
2. 브로커 계층은 유틸리티 계층에만 의존해야 한다
3. API 계층은 코어 및 브로커 계층에 의존하되 대시보드에는 의존하지 않아야 한다
4. 대시보드는 API 계층에만 의존해야 한다
5. 한 계층이 다른 계층의 기능을 필요로 할 때, 의존성은 허용된 방향으로만 흘러야 한다

### 요구사항 8

**사용자 스토리:** 개발자로서, 나는 OHLC 및 실시간 가격에 대한 포괄적인 데이터 관리를 원한다. 그래야 전략이 시장 데이터에 안정적이고 빠르게 접근할 수 있기 때문이다.

#### 인수 기준

1. OHLC 데이터가 요청될 때, 데이터 수집기는 브로커에서 가져오기 전에 먼저 캐시(Redis 또는 로컬 저장소)를 확인해야 한다
2. 실시간 가격이 수신될 때, 시스템은 만료 시간과 함께 Redis에 캐시해야 한다
3. 과거 데이터가 가져와질 때, 시스템은 향후 사용을 위해 MinIO 또는 로컬 파일 저장소에 저장해야 한다
4. 시스템은 백테스트 결과, 전략 설정, 거래 이력을 저장하기 위해 PostgreSQL 또는 SQLite를 지원해야 한다
5. 데이터가 누락되거나 오래된 경우, 데이터 수집기는 브로커에서 새로운 데이터를 가져와 캐시를 업데이트해야 한다

### 요구사항 9

**사용자 스토리:** 트레이더로서, 나는 실행 엔진에 내장된 리스크 관리 기능을 원한다. 그래야 과도한 손실로부터 자본을 보호할 수 있기 때문이다.

#### 인수 기준

1. 전략이 주문을 제출하려고 할 때, 리스크 매니저는 주문이 포지션 크기 한도를 초과하지 않는지 확인해야 한다
2. 계좌 MDD가 설정된 임계값에 도달할 때, 리스크 매니저는 모든 전략에 대해 긴급 정지를 트리거해야 한다
3. 일일 손실이 설정된 한도를 초과할 때, 리스크 매니저는 다음 거래일까지 새로운 주문을 방지해야 한다
4. 리스크 매니저는 계좌 자산을 기반으로 실시간으로 MDD를 계산하고 추적해야 한다
5. 포지션이 개설될 때, 리스크 매니저는 설정된 경우 손절 및 익절 수준을 강제해야 한다

### 요구사항 10

**사용자 스토리:** 개발자로서, 나는 모든 코드가 타입 힌트와 비동기 패턴을 갖춘 Python 모범 사례를 따르기를 원한다. 그래야 코드베이스가 견고하고 성능이 좋기 때문이다.

#### 인수 기준

1. 시스템은 Python 3.10 이상을 사용해야 한다
2. 함수 또는 메서드가 정의될 때, 모든 파라미터와 반환 값에 대한 타입 힌트를 포함해야 한다
3. I/O 작업(API 호출, 데이터베이스 쿼리, 파일 작업)이 수행될 때, 코드는 async/await 패턴을 사용해야 한다
4. 시스템은 명확한 관심사 분리를 가진 모듈로 코드를 구성해야 한다
5. 클래스가 정의될 때, 단일 책임 원칙을 따르고 적절한 경우 의존성 주입을 사용해야 한다

