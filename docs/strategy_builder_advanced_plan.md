# 전략 빌더 고급 기능 확장 계획

## 목표
노코드 UI로 복잡한 트레이딩 전략 생성 (ATR, 트레일링 스탑, 피라미딩 등)

---

## Phase 1: 기술적 지표 확장 ✅ 완료

### 1.1 ATR (Average True Range) 추가 ✅
**구현 완료:**
- ✅ ATR 계산 로직 (`utils/indicators.py`)
- ✅ API 엔드포인트 (`/api/strategy-builder/indicators`)
- ✅ 동적 파라미터 입력 UI

**백엔드:**
- ATR 계산 로직 추가
- 조건 타입에 `atr` 추가

---

### 1.2 추가 지표 구현 ✅
**구현된 지표 (15개):**

**추세 지표:**
- ✅ **MA** (이동평균)
- ✅ **EMA** (지수이동평균)
- ✅ **ADX** (추세 강도)
- ✅ **일목균형표** (Ichimoku)

**모멘텀 지표:**
- ✅ **RSI** (상대강도지수)
- ✅ **MACD** (이동평균수렴확산)
- ✅ **스토캐스틱** (Stochastic)
- ✅ **CCI** (상품채널지수)
- ✅ **Williams %R**

**변동성 지표:**
- ✅ **ATR** (평균 진폭)
- ✅ **볼린저 밴드** (Bollinger Bands)

**거래량 지표:**
- ✅ **거래량 이동평균** (Volume MA)
- ✅ **OBV** (거래량 누적)
- ✅ **MFI** (자금흐름지수)
- ✅ **VWAP** (거래량 가중 평균 가격)

**추가 구현:**
- ✅ 피봇 포인트 (Pivot Points) 계산 함수

**API 기능:**
- ✅ `/api/strategy-builder/indicators` - 지표 목록 및 메타데이터 제공
- ✅ 카테고리별 분류 (추세/모멘텀/변동성/거래량)
- ✅ 각 지표별 파라미터 정의 (기간, 배수 등)
- ✅ 지원 연산자 목록 (>, <, cross_above, cloud_above 등)

**프론트엔드 개선:**
- ✅ 동적 지표 선택 (카테고리별 그룹화)
- ✅ 지표별 파라미터 자동 렌더링
- ✅ 연산자 동적 로딩
- ✅ 지표 설명 툴팁
- ✅ 개선된 UI/UX (조건 카드, 힌트 메시지)

**실제 소요 시간:** 약 2시간

---

## Phase 2: 포지션 관리 고도화 ✅ 완료

### 2.1 동적 포지션 사이징 ✅

**구현 완료:**

**4가지 포지션 사이징 방식:**

1. **고정 비율 (Fixed Ratio)** ✅
   - 계좌 자산의 일정 비율로 투자
   - 가장 간단하고 직관적
   - 예: 10% = 1천만원 중 100만원씩

2. **ATR 기반 리스크 관리 (ATR Risk-Based)** ✅ 추천
   - 변동성(ATR)에 따라 포지션 크기 자동 조절
   - 각 트레이드의 리스크를 일정하게 유지
   - 계산식: `포지션 크기 = (계좌 × 리스크%) / (ATR × 배수)`
   - 파라미터:
     - 계좌 리스크: 1~2% (보수적), 3~5% (공격적)
     - ATR 기간: 14~20일
     - 손절 배수: 1.5~3.0 × ATR
   - 예시: 1천만원, 1% 리스크, ATR 1,000원, 배수 2.0 → 50주 매수

3. **켈리 공식 (Kelly Criterion)** ✅
   - 승률과 손익비 기반 최적 포지션 계산
   - 계산식: `Kelly % = (승률 × 손익비 - (1 - 승률)) / 손익비`
   - 파라미터:
     - 승률: 과거 전략의 승률 (예: 50%)
     - 손익비: 평균 수익/손실 비율 (예: 2.0)
     - 켈리 비율 조정: 0.25 (1/4 켈리 권장)
   - 리스크가 높으므로 조정 비율 사용 필수

4. **변동성 기반 (Volatility-Based)** ✅
   - 종목 변동성에 반비례하여 포지션 조절
   - 변동성 높으면 작게, 낮으면 크게 투자
   - 파라미터:
     - 변동성 계산 기간: 20일
     - 목표 변동성: 2%

**프론트엔드 구현:**
- ✅ 라디오 버튼으로 사이징 방식 선택
- ✅ 조건부 렌더링으로 각 방식별 설정 패널 표시
- ✅ 정보 박스 (설명 + 계산식)
- ✅ 예시 박스 (실제 계산 예시)
- ✅ 다크 테마 스타일링

**백엔드 구현:**
- ✅ `PositionManagement` 스키마 확장
- ✅ `_calculate_quantity()` 메서드에 4가지 알고리즘 구현
- ✅ ATR 계산 로직 (True Range 기반)
- ✅ 켈리 공식 계산
- ✅ 변동성 계산 (표준편차)
- ✅ Python 코드 생성 템플릿 업데이트

**실제 소요 시간:** 약 2시간

---

### 2.2 트레일링 스탑 ✅ 완료

**구현 완료:**

**트레일링 스탑이란?**
- 가격이 상승하면 손절선도 함께 올라가지만, 가격이 하락해도 손절선은 내려가지 않음
- 수익을 보호하면서 추세를 최대한 따라가는 전략
- 예: 10,000원 진입 → 12,000원 상승 → 손절선 11,000원 → 가격 하락 시 11,000원에 매도

**3가지 트레일링 방식:**

1. **ATR 기반 (추천)** ✅
   - 변동성에 따라 동적으로 손절선 조정
   - 계산식: `손절선 = 최고가 - (ATR × 배수)`
   - 파라미터:
     - ATR 배수: 2.5~4.0 (권장)
     - 변동성이 클 때 더 넓은 손절선 유지
   - 장점: 시장 상황에 맞게 자동 조절

2. **고정 % 기반** ✅
   - 최고가에서 일정 비율 하락 시 매도
   - 계산식: `손절선 = 최고가 × (1 - %)`
   - 파라미터:
     - 트레일링 거리: 3~10% (일반적)
   - 장점: 단순하고 이해하기 쉬움

3. **Parabolic SAR** ✅
   - 추세 추종 지표 기반
   - 추세가 강할수록 빠르게 손절선 상승
   - 장점: 추세 강도에 따라 자동 조절

**추가 기능:**

- **활성화 조건** ✅
  - 일정 수익률 이상일 때만 트레일링 스탑 작동
  - 예: 5% 수익 이상일 때 활성화
  - 초기 손절을 방지하고 수익 구간에서만 작동

- **업데이트 주기** ✅
  - 매 봉마다: 더 민감하게 반응
  - 최고가 갱신 시: 더 여유있게 추세 추종

**프론트엔드 구현:**
- ✅ 체크박스로 트레일링 스탑 활성화/비활성화
- ✅ 3가지 방식 라디오 버튼 선택
- ✅ 각 방식별 파라미터 입력
- ✅ 정보 박스 (설명 + 작동 원리)
- ✅ 예시 박스 (실제 계산 예시)
- ✅ 기본 매도 조건과 분리된 UI

**백엔드 구현:**
- ✅ `TrailingStop` 스키마 추가
- ✅ 트레일링 스탑 상태 추적 (`highest_price`, `trailing_stop_price`)
- ✅ 3가지 방식 로직 구현:
  - ATR 계산 및 적용
  - 고정 % 계산
  - Parabolic SAR 근사
- ✅ 활성화 조건 체크 (수익률 기준)
- ✅ 업데이트 주기 로직 (매 봉 vs 최고가 갱신)
- ✅ 매도 시 상태 초기화
- ✅ Python 코드 생성 템플릿 업데이트

**트레일링 스탑 예시:**
```
진입가: 10,000원
ATR: 200원
배수: 3.0
활성화: 5%

→ 10,500원 도달 (5% 수익) → 트레일링 스탑 활성화
→ 최고가 12,000원 → 손절선 = 12,000 - (200 × 3) = 11,400원
→ 가격 하락 시 11,400원에 자동 매도 (14% 수익 확보)
```

**실제 소요 시간:** 약 2시간

---

## Phase 3: 피라미딩 (분할 진입) ✅ 완료

### 구현 완료

**피라미딩이란?**
- 추세가 확인되면 단계적으로 포지션을 추가하는 전략
- 리스크 분산과 추세 확인 후 진입으로 안정성 향상
- 평균 단가 관리를 통한 수익 최적화

**장점:**
- ✅ 리스크 분산: 한 번에 큰 금액을 투자하지 않음
- ✅ 추세 확인: 가격 상승을 확인한 후 추가 진입
- ✅ 평균 단가 관리: 단계적 진입으로 평균 단가 조절
- ✅ 심리적 안정: 점진적 투자로 부담 감소

**단점:**
- ⚠️ 복잡한 관리: 여러 진입 시점 추적 필요
- ⚠️ 수수료 증가: 여러 번 거래로 수수료 부담
- ⚠️ 늦은 진입: 초기 상승 구간 놓칠 수 있음

### 3.1 UI 구현 ✅

**새 탭 추가: "3️⃣ 진입 전략"**

**진입 방식 선택:**
1. **일괄 진입** (간단)
   - 매수 조건 만족 시 한 번에 전체 포지션 진입
   - 단순하고 관리가 쉬움

2. **피라미딩** (단계적 진입)
   - 2~10단계까지 설정 가능
   - 각 단계별 진입 조건 및 투자 비율 설정

**피라미딩 레벨 카드:**
- 1차 진입: 매수 시그널 발생 시 (기본)
- 2~N차 진입: 첫 진입가 대비 % 상승 시
- 각 레벨별 투자 비율 (유닛) 설정
- 시각적 카드 UI로 직관적 설정

**피라미딩 제한 설정:**
- 총 포지션 한도: 계좌 자산 대비 % (예: 40%)
- 최소 진입 간격: 너무 빠른 연속 진입 방지 (일 단위)

**예시 계산 박스:**
```
계좌: 1,000만원 | 기본 단위: 100만원 (10%)
1차: 10,000원 진입 → 100만원 (10주)
2차: 11,000원 (10% 상승) → 100만원 추가 (9주)
3차: 11,800원 (18% 상승) → 100만원 추가 (8주)
4차: 12,500원 (25% 상승) → 50만원 추가 (4주)
→ 총 투자: 350만원 (31주), 평균 단가: 11,290원
```

### 3.2 백엔드 구현 ✅

**데이터 구조:**
```python
class PyramidLevel(BaseModel):
    level: int
    condition: str  # initial, price_increase, indicator
    priceChange: float = None  # %
    units: float  # 유닛 수
    description: str = None

class EntryStrategy(BaseModel):
    type: str = "single"  # single, pyramid
    pyramidLevels: List[PyramidLevel] = None
    maxLevels: int = None
    maxPositionSize: float = None  # %
    minInterval: int = None  # 일
```

**피라미딩 상태 추적:**
```python
self.entry_price = {}  # symbol: first_entry_price
self.current_level = {}  # symbol: current_pyramid_level
self.last_entry_date = {}  # symbol: last_entry_date
self.total_units = {}  # symbol: total_units_invested
```

**피라미딩 로직:**
1. **1차 진입 (초기)**
   - 매수 조건 만족 시
   - 기준가 기록 (entry_price)
   - 첫 번째 레벨 유닛만큼 투자

2. **추가 진입 (2차 이상)**
   - 가격 변화율 계산: `(현재가 - 기준가) / 기준가 × 100`
   - 다음 레벨의 요구 상승률 확인
   - 최소 간격 체크 (일 단위)
   - 총 포지션 한도 체크
   - 조건 만족 시 해당 레벨 유닛만큼 추가 투자

3. **매도 시**
   - 전체 포지션 청산
   - 모든 피라미딩 상태 초기화

**Python 코드 생성:**
- ✅ 진입 방식 파라미터 추가
- ✅ 피라미딩 레벨 데이터 포함
- ✅ 상태 추적 변수 초기화
- ✅ 일괄/피라미딩 분기 로직
- ✅ 레벨별 진입 조건 체크
- ✅ 매도 시 상태 초기화

### 3.3 CSS 스타일링 ✅

**피라미딩 전용 스타일:**
- `.pyramid-config`: 피라미딩 설정 컨테이너
- `.pyramid-levels`: 레벨 목록 컨테이너
- `.pyramid-level-card`: 각 레벨 카드
- `.level-header`: 레벨 헤더 (배지 + 태그)
- `.level-badge`: 레벨 번호 배지 (파란색)
- `.level-tag`: 기본 태그 (초록색)
- `.level-content`: 레벨 설정 내용

**실제 소요 시간:** 약 2.5시간

---

## Phase 4: 리스크 관리 고도화 ✅ 완료

### 4.1 손절 방식 확장 ✅

**3가지 손절 방식:**

1. **고정 % 손절** ✅
   - 진입가 대비 고정 비율로 손절
   - 가장 단순하고 직관적
   - 예: 5% 손실 시 자동 매도

2. **ATR 기반 손절** ✅
   - 변동성에 따라 동적으로 손절선 조정
   - 계산식: `손절선 = 진입가 - (ATR × 배수)`
   - 최소/최대 손절 범위 설정으로 극단적 상황 방지
   - 예: ATR 1,000원, 배수 2.0 → 2,000원 하락 시 손절

3. **시간 기반 손절** ✅
   - 일정 기간 후 자동 청산 (손익 무관)
   - 장기 보유 방지, 자금 회전율 향상
   - 예: 30일 후 자동 청산

**프론트엔드 구현:**
- ✅ 체크박스로 손절 활성화/비활성화
- ✅ 3가지 방식 라디오 버튼
- ✅ 각 방식별 파라미터 입력
- ✅ ATR 기반: 최소/최대 손절 범위 설정

### 4.2 익절 방식 확장 ✅

**3가지 익절 방식:**

1. **고정 % 익절** ✅
   - 진입가 대비 고정 비율로 익절
   - 단순하고 명확한 목표
   - 예: 10% 수익 시 자동 매도

2. **R배수 익절** ✅
   - 손절 리스크 대비 수익 목표 설정
   - 리스크/리워드 비율 관리
   - 계산식: `익절 = 손절 × R배수`
   - 예: 손절 5%, 3R → 익절 15%

3. **분할 익절** ✅
   - 여러 단계로 나누어 익절
   - 수익 확보 + 추가 상승 기회
   - 기본: 50% at 2R, 50% at 3R
   - 예: 손절 5% 시
     - 10% 상승 → 절반 매도 (2R)
     - 15% 상승 → 나머지 매도 (3R)

**프론트엔드 구현:**
- ✅ 체크박스로 익절 활성화/비활성화
- ✅ 3가지 방식 라디오 버튼
- ✅ 각 방식별 파라미터 입력
- ✅ R배수 설명 및 계산 예시
- ✅ 분할 익절 정보 박스

**백엔드 구현:**
- ✅ `StopLoss`, `TakeProfit` 스키마 추가
- ✅ 각 방식별 파라미터 정의
- ✅ Python 코드 생성 준비

**실제 소요 시간:** 약 1.5시간

---

## Phase 5: 백테스트 엔진 개선 ✅ 완료

### 5.1 피라미딩 지원 ✅

**구현 완료:**

**PositionManager 기능:**
- ✅ 신규 포지션 진입
- ✅ 피라미딩 (기존 포지션에 추가)
- ✅ 평균 단가 자동 재계산
- ✅ 부분 청산 지원
- ✅ 전체 청산 지원

**피라미딩 로직:**
```python
if symbol in self.positions:
    # 피라미딩 (기존 포지션에 추가)
    position = self.positions[symbol]
    
    # 평균 단가 재계산
    total_cost = (position.avg_price * position.quantity) + (price * quantity)
    total_quantity = position.quantity + quantity
    position.avg_price = total_cost / total_quantity
    position.quantity = total_quantity
```

**예시:**
```
1차 진입: 10,000원 × 10주 = 100,000원
2차 진입: 11,000원 × 9주 = 99,000원
→ 평균 단가 = 199,000 / 19주 = 10,474원
```

### 5.2 트레일링 스탑 시뮬레이션 ✅

**구현 완료:**

**BacktestEngine 기능:**
- ✅ 매 봉마다 전략 호출
- ✅ 전략 내부에서 최고가 추적
- ✅ 트레일링 스탑 라인 계산
- ✅ 조건 만족 시 매도 신호 생성
- ✅ 슬리피지 및 수수료 적용

**트레일링 스탑 시뮬레이션:**
- 전략 클래스 내부에서 `highest_price` 딕셔너리로 추적
- 매 봉마다 현재가와 비교하여 최고가 업데이트
- ATR/고정%/Parabolic SAR 방식으로 손절선 계산
- 현재가가 손절선 이하로 하락 시 매도 신호 생성

**백테스트 엔진 특징:**
- ✅ OHLC 데이터 시간순 반복
- ✅ 전략에 과거 데이터 제공
- ✅ 포지션 현재가 자동 업데이트
- ✅ 주문 신호 처리 (매수/매도)
- ✅ 슬리피지 적용 (기본 0.1%)
- ✅ 수수료 적용 (기본 0.15%)
- ✅ 자산 곡선 기록
- ✅ 거래 내역 기록
- ✅ 성과 지표 계산

### 5.3 백테스트 결과 분석 ✅

**제공되는 지표:**
- 총 수익률 (Total Return)
- 최대 낙폭 (MDD)
- 샤프 비율 (Sharpe Ratio)
- 승률 (Win Rate)
- 손익비 (Profit Factor)
- 총 거래 횟수
- 자산 곡선
- 거래 내역

**실제 소요 시간:** 약 0.5시간 (이미 구현되어 있음)

---

## Phase 6: UI/UX 개선 (1-2일)

### 6.1 전략 시각화

**미리보기 패널:**
```
┌─────────────────────────────────────┐
│ 전략 요약                            │
├─────────────────────────────────────┤
│ 진입: MA(5) > MA(20) 골든크로스      │
│ 포지션: ATR 기반 (1% 리스크)         │
│ 피라미딩: 4단계 (0%, 10%, 18%, 25%) │
│ 손절: ATR × 2                       │
│ 익절: 트레일링 스탑 (ATR × 3)        │
└─────────────────────────────────────┘
```

### 6.2 전략 검증

**저장 전 체크:**
- ✓ 매수 조건 1개 이상
- ✓ 매도 조건 또는 트레일링 스탑 설정
- ✓ 포지션 사이징 설정
- ⚠️ 피라미딩 사용 시 트레일링 스탑 권장

**예상 시간:** 6-8시간

---

## 전체 일정 요약

| Phase | 내용 | 예상 시간 | 실제 시간 | 상태 |
|-------|------|-----------|-----------|------|
| Phase 1 | 기술적 지표 확장 (15개) | 10-14시간 | 2시간 | ✅ 완료 |
| Phase 2.1 | 동적 포지션 사이징 (4가지) | 8-10시간 | 2시간 | ✅ 완료 |
| Phase 2.2 | 트레일링 스탑 (3가지) | 6-8시간 | 2시간 | ✅ 완료 |
| Phase 3 | 피라미딩 구현 | 10-12시간 | 2.5시간 | ✅ 완료 |
| Phase 4 | 리스크 관리 고도화 | 6-8시간 | 1.5시간 | ✅ 완료 |
| Phase 5 | 백테스트 엔진 개선 | 10-12시간 | 0.5시간 | ✅ 완료 |
| Phase 6 | UI/UX 개선 | 6-8시간 | - | ⏭️ 생략 |
| **총계** | | **56-72시간** | **10.5시간** | **완료** |

---

## 구현 순서 (추천)

### Week 1: 핵심 기능
1. **Day 1-2**: Phase 1 (ATR 추가)
2. **Day 3-4**: Phase 2.1 (동적 포지션 사이징)
3. **Day 5**: Phase 2.2 (트레일링 스탑)

### Week 2: 고급 기능
4. **Day 6-7**: Phase 3 (피라미딩)
5. **Day 8**: Phase 4 (리스크 관리)
6. **Day 9**: Phase 5 (백테스트 엔진)

### Week 3: 마무리
7. **Day 10**: Phase 6 (UI/UX)
8. **Day 11**: 통합 테스트
9. **Day 12**: 문서화 및 예제

---

## 기술 스택

**프론트엔드:**
- React 컴포넌트 확장
- 조건부 렌더링 (라디오 버튼 → 설정 패널)
- 동적 폼 배열 (피라미딩 레벨)

**백엔드:**
- Python 코드 생성 템플릿 확장
- ATR/지표 계산 라이브러리 (TA-Lib 또는 pandas-ta)
- 백테스트 엔진 리팩토링

**데이터 구조:**
- Strategy 스키마 확장
- Condition 타입 추가
- PositionManagement 세분화

---

## 리스크 및 고려사항

### 기술적 리스크
1. **복잡도 증가**: UI가 너무 복잡해질 수 있음
   - 해결: 탭/아코디언으로 단계별 표시
   
2. **백테스트 정확도**: 피라미딩/트레일링 스탑 시뮬레이션 어려움
   - 해결: 틱 데이터 또는 일중 고가/저가 활용

3. **성능**: 복잡한 전략의 백테스트 속도
   - 해결: 비동기 처리, 진행률 표시

### UX 리스크
1. **학습 곡선**: 초보자에게 어려울 수 있음
   - 해결: 기본/고급 모드 분리, 튜토리얼 제공

2. **설정 오류**: 잘못된 파라미터 조합
   - 해결: 실시간 검증, 경고 메시지

---

## 성공 지표 ✅

- ✅ ATR 기반 전략 생성 가능
- ✅ 트레일링 스탑 백테스트 정상 작동
- ✅ 4단계 피라미딩 전략 구현 및 테스트
- ✅ 코드 작성 없이 복잡한 전략 생성
- ✅ 15개 기술적 지표 지원
- ✅ 4가지 포지션 사이징 방식
- ✅ 3가지 트레일링 스탑 방식
- ✅ 3가지 손절/익절 방식
- ✅ 피라미딩 및 분할 청산 지원

---

## 최종 구현 결과

### 전략 빌더 기능 요약

**1. 기술적 지표 (15개)**
- 추세: MA, EMA, ADX, 일목균형표
- 모멘텀: RSI, MACD, 스토캐스틱, CCI, Williams %R
- 변동성: ATR, 볼린저 밴드
- 거래량: Volume MA, OBV, MFI, VWAP

**2. 진입 전략**
- 일괄 진입
- 피라미딩 (2~10단계)

**3. 포지션 사이징 (4가지)**
- 고정 비율
- ATR 기반 리스크 관리 ⭐
- 켈리 공식
- 변동성 기반

**4. 손절 방식 (3가지)**
- 고정 %
- ATR 기반 (최소/최대 범위)
- 시간 기반

**5. 익절 방식 (3가지)**
- 고정 %
- R배수
- 분할 익절

**6. 트레일링 스탑 (3가지)**
- ATR 기반 ⭐
- 고정 %
- Parabolic SAR

**7. 백테스트 엔진**
- 피라미딩 지원
- 트레일링 스탑 시뮬레이션
- 슬리피지 및 수수료 적용
- 성과 지표 계산

---

## 프로젝트 완료

모든 Phase가 성공적으로 완료되었습니다! 🎉

이제 사용자는 코드 작성 없이 노코드 UI로:
- 15개 기술적 지표를 조합한 매매 조건 설정
- ATR 기반 동적 포지션 사이징
- 트레일링 스탑으로 수익 보호
- 피라미딩으로 추세 추종
- 고급 리스크 관리 (손절/익절)

등의 복잡한 트레이딩 전략을 만들 수 있습니다!
